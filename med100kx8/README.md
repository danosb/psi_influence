# med100kx8
The presented program is a modular and multithreaded data collection and analysis application for psychokinesis experiments, using a true random number generator (the med100kx8) as a device under test. It's written in Python and uses MySQL for data storage. The condensed version of this project, which does not store any data for later analysis and thus is much simpler to configure, can be found [here](https://github.com/danosb/quantum_influence/tree/main/med100kx8_no_db). Using a database allows a huge amount of data to be stored, that can be referenced during later data analysis.


## Program Summary

The program overview is as follows:

1. The user inputs their participant information including their personal data, some environmental info, and the settings for the trial.

1. The program connects to the random number generator, gets the raw bytes from it, and converts these bytes to binary strings of 1s and 0s.

1. It uses Scott Wilber's Random Walk Bias Amplification (RWBA) method with advanced processing methods for increased effect size in anomalous cognition [details](https://drive.google.com/file/d/1rP7Ee35K0kbQ3zXCcZvnj3d5WqmROTT_/view). By default we use a bound of 31, which is the distance to the upper or lower bound. Basically every 1 that's generated is a step to the right, every 0 generated is a step to the left. This runs until either the upper or lower bound of 31 / -31 is hit. We track how many steps it took to hit the bound and which bound was hit.

1. Results are then grouped into subtrials, trials, windows, window groups, and supertrials. A subtrial consists of one attempt to hit an upper or lower bound. By default there are 21 subtrials per trial, 5 trials per window, 10 windows per window group. A window lasts roughly 1 second. A supertrial equals one overall program execution, which can be configured either to execute indefinitely or based on a configured amount of seconds.

1. For each trial, window, and window group we calculate p and z values to determine probability of randomness. Both one-tailed (targeting either just more 1s or just more 0s) and two-tailed (targeting both more 1s and more 0s) are supported in a given supertrial. All results are saved to the database.

1. Calculated probability values are used to control a graphic window that displays a spinning cube, a bar-chart, and if two-tailed is selected then an on/off light. Behavior of objects and displayed values is controlled by window group probabilities. The goal is to influence the output of the random number generator in such a way so as to reach targets in the graphical window. 

1. This program makes use of a multi-threaded design for concurrent processing of data extraction, analysis, and database writing tasks. It also uses a pooled MySQL connection for efficient database operations. Speed is of critical importance because we want to use all or mostly all of the bits generated by the random number generator.


## Data Collected

In addition to experiment probability outcomes (discussed further in the **Understanding console output** section, and which are also stored in the database), this code captures a large number of variables during experimental runs in order to enable subsequent data analysis to be done.

I think there's good reason to believe that successful psi influence is a result of a variety of variables coming together in just the right way, but which variables have input and to what degree is not well understood. The version of the code that uses a database stores information for many different types of variables, which I deemed to have the best potential based on review of the admittedly limited research that's available. These include:

- **Participant age** - Entered manually
- **Participant overall feeling** - Subjective evaluation manually entered
- **Participant energy level** - Subjective evaluation manually entered
- **Participant focus level** - Subjective evaluation manually entered
- **Whether participant ate** in the last 90 minutes - Manually entered
- **Whether participant meditated** recently - Manually entered
- **Current environment temperature** - Manually entered
- **Current environment humidity** - Manually entered
- **Solar DST Index** - A measure of the disturbance level in the Earth's magnetosphere caused by solar wind variations. It is used to quantify the intensity of geomagnetic storms and their effects on Earth's magnetic field. This is pulled automatically in real-time from from the World Data Center for Geomagnetism.
- **The Kp geomagnetic index** - A measurement of the global geomagnetic activity level. It quantifies the disturbances in the Earth's magnetic field caused by solar activity, specifically related to coronal mass ejections (CMEs) and solar flares. This is pulled automatically in real-time from the German Research Centre for Geosciences.
- **Galvanic Skin Response** - Galvanic skin response (GSR) is a method of measuring the electrical conductance of the skin. Strong emotion can cause stimulus to your sympathetic nervous system, resulting more sweat being secreted by the sweat glands. Code is written to use the [Grove GSR Sensor](https://wiki.seeedstudio.com/Grove-GSR_Sensor/) connected to a [Raspberry Pi](https://www.raspberrypi.com/). (**Note**: In current code values are captured and printed but not stored to the database, that needs to be done still.)
- **Lots of EEG Data** - Captures real-time brainwave data from the user. Code is written to read data from an [Emotiv Epoch EEG](https://www.emotiv.com/products/epoc-x) using a node-red server and Mosquitto (in theory would work the same with any Emotiv device). It's all working, and includes not just the ability to measure raw brainwave signals (**alpha, beta-high, beta-low, gamma, theta**) but, interestingly, also uses Emotiv's algorithms to assign objective values to level of **excitement, focus, interest, engagement, stress, relaxation, longterm excitement, attention,** and **cognitive stress**. Similar to the GSR portion, the current code is capturing data but not yet storing it to the database. This produces an immense amount of data and I never quite decided if I wanted to store it all in raw form or average/aggregate it somehow before storage.
- **Technique to be used during session** - Options include:
    1. Visualization
    2. Attempt to identify/merge with the device or process
    3. Affirmation or assertive based approach
    4. Passive attention
    5. Generation of intense energy or emotion
    6. Focus on feelings on successful outcome
    7. General mind-quieting and focus
    8. Focus on feeling love
    9. General focus / other

My initial intent, which I never fully realized, was to do a large number of experiments while measuring all of this data. Since it's being stored to the database it can then be analyzed later, likely using machine learning or even "AI", to find correlations between positive psi outcomes and values of specific variables (e.g. perhaps we find a certain value for the Solar DST index that is conducive to psi). In theory, after identifying the variables most conducive to psi, these could be fed back into algorithms to further enhance our ability to measure psi influence (e.g. perhaps we only "count" a measurement when variables are most conducive to successful outcomes).

## Understanding console output:

**z-value**, **p-value**, and **surprisal value** are all just different ways of viewing the probability of the selected outcome occurring randomly. You can convert between them with algorithms. In the context of probability theory, **z-value** and **p-value** are very common. 
- **z-value** (also known as a z-score) represents the number of standard deviations an observation or statistic is from the mean of a standard normal distribution. 
- **p-value** is the probability of observing a value as extreme as, or more extreme than, the z-score under the null hypothesis. This is a value between 0 and 1 and as such can be easily translated to a percentage (e.g. p=0.05 means 5% probability of results being random).
- **surprisal value** is less commonly used. In the context of Scott's paper here, the **surprisal value** (SV) is calculated from the p-value and uses weights to provide a more uniform range of probabilistic outcomes.

The thing you'll see used most in other studies, and perhaps the simplest to understand, is the **p-value**. A commonly used threshold to denote statistical significance is p < 0.05 (5% probability of being random). p < 0.005 (0.5% chance of being random) is considered **very significant**. It's important to note that in the code I've shared above I made a choice to invert the **p-value** (1-p). So, instead of targeting p < 0.05 we instead target p > 0.95. I found this to be more intuitive since I wanted the cube to spin faster when the results were less probable, and it felt more natural to have the faster spinning speed associated with a higher numeric value.

It may seem confusing that we are using **subtrials**, **trials**, **windows**, and **window groups**. In effect, each of these is an aggregation of the thing before it (a group of subtrials is a **trial**, a group of trials is a **window**, a group of windows is a **window group**). Studies have shown the effects of psi to be small, but statistically significant over large data-sets. It takes a lot of data to ensure that an anomalous effect is really occurring (e.g., if I flip a coin 4 times, and get heads 3 times, the probability of this happening randomly is quite high). As such, tests require a lot of data, and subsequent statistical analysis on that date. The general purpose and intent of Scott's approach here is to amplify and identify the impact of any anomalous (aka psychokinetic, or psi) effects. If we get a positive result in a single subtrial, or even trial, in isolation it doesn't tell us much, but looking at large volumes of subtrial outcomes over time (via windows or window groups) gives us much more data and thus we can evaluate the probability of anomalous effect (psi) occurring with much greater confidence.

Lastly, to reference the two other values returned in the console during program execution...
- **Last window was hit? (yes/no)** - This only applies to, and is only returned during, one-tailed analysis (when doing uni-directional targeting - only more 1s or alternatively only more 0s). For one-tailed analysis, a window hit is determined based on whether the **z-value** for that window has a polarity (positive or negative value) corresponding to the target direction (if targeting more 1s then a positive z-value for the window corresponds to a *hit*/*success*, if targeting more 0s then a negative z-value is a *hit*). In one-tailed we use the number of hits within a window group to calculate window group p and z values. For two-tailed analysis (where we watch for both more 1s and more 0s) window hits are not used to calculate window group p or z values. 
- **Running overall window bound tracker** - For both one-tailed and two-tailed, in effect, this tracks consecutive z-value polarity for successive window outcomes. So, if a window has a z-value that's positive then our bound tracker adds 1. If a window has a z-value that's negative then we subtract one. The tracker maxes out at +5 and -5 (e.g., if it's at -5 and we get a z-value < 0 then we do not subtract 1). This running bound isn't actually used for anything meaningful, neither in terms of probability calculations nor visual effects in the graphical window.

All of these values, and more, are also stored in the database in addition to being returned in the console.

## Files

Here's a brief description of the files:

* **db_setup.sql**: Configures database schema.
* **main.py**: The main execution script for the program. 
* **get_supertrial**: Pulls the last supertrial ID from the database.
* **extract_numbers.py**: Extracts raw bytes from the random number generator and converts them into binary strings.
* **analyze_subtrial.py**: Performs the random walk basis analysis to determine whether upper or lower bound is hit, and in how many steps.
* **process_trial.py**: Combines subtrial data into trials and performs some analysis.
* **get_dst.py**: Retreives and stores the Solar DST (Solar Dst Index), a measure of the disturbance level in the Earth's magnetosphere caused by solar wind variations.
* **get_kp.py**: Retreives and stores the Kp geomagnetic index, a measurement of the global geomagnetic activity level, as well as other solar data. 
* **graphic.py**: Generates and controls the graphic window with the spinning cube, bar-chart, on/off switch, and displayed data.
* **p_and_z_funcs.py**: Used to calculate probabilities of trials, windows, and window groups.
* **participant.py**: Prompts the user for input data (personal, environtal, supertrial configurations).
* **write_to_database.py**: Controls writes to the database.
* **list_serial.py**: A debugging file that lists all connected devices.
* **gsr_client.py**: Reads data from an external galvanic skin response sensor. **This function incomplete**
* **gsr_server.py**: Code that runs on a Raspberry Pi powering external galvanic skin response sensor. **This function incomplete**
* **eeg.py**: Reads data from an Emotiv Epoch EEG using a node-red server and mosquitto. **This function incomplete**

## Pre-Setup Instructions

1. Ensure that pip and Python 3.6 or later are installed
1. Run the following:
   
    ```pip install mysql pymysql pyftdi datetime scipy dbutils requests pytz libusb urllib3 pygame numpy pyopengl libusb1 PyOpenGL_accelerate```
   
    ```pip install playsound==1.2.2```
   
## Windows Setup Instructions

1. Install MySQL Server community: https://dev.mysql.com/downloads/installer/
- Install MySQL Server and MySQL Shell
- Set root password to your desired password
- Start MySQL Server local instance

2. Connect to local MySQL database server using the client above (or a different one), run quantum_influence/med100kx8/db_setup.sql to configure the database.

3a. Option 1: Replace the password below and enter the text below in a terminal (will have to be re-entered after closing terminal)

    set MYSQL_USER=root
    set MYSQL_PASSWORD=**YOUR PASSWORD**
    set MYSQL_HOST=localhost
    set MYSQL_DB=myDatabase

3b. Option 2: 
In order to avoid having to enter the above variables everytime you restart the terminal, add tee above as environment variables within Windows. 
- System properties > Advances > Environment Variables

4. Install FTDI drivers: https://ftdichip.com/wp-content/uploads/2021/08/CDM212364_Setup.zip (*Not sure if this is truly necessary, but including just in case)

5. Download https://zadig.akeo.ie/
- Options > List all devices
- Find med100kx8
- Change driver to libusb-win32 and click Replace


## OSX Setup Instructions

1. Run MySQL\
    ```$ mysqld&```
2. Connect to MySQL\
    ```% mysql -u root```
3. Create the database\
    ```mysql> create database myDatabase;```\
    ```mysql> \q```
   
4a. Update password and run in terminal\
    ```$ export MYSQL_USER=root```\
    ```$ export MYSQL_PASSWORD=```\
    ```$ export MYSQL_HOST=localhost```\
    ```$ export MYSQL_DB=myDatabase```
   
4b. Optional, to make the above environment variables permanent in macOS (OS X), you can add them to your shell configuration file, such as ~/.bash_profile or ~/.bashrc. Otherwise, you have to re-enter these after each terminal restart.

5. Goto folder and create database tables\
    ```$ cd quantum_influence/med100kx8```\
    ```$ mysql -u root myDatabase < db_setup.sql```


## Running

1. Navigate to quantum_influence\med100kx8 directory in terminal
   
```python main.py```\
or \
```python3 main.py```



## Demo (click image)

Two-tailed (turn device on/off) with indefinite run-time selected (click for video):

[![Demo on Youtube](https://i.ibb.co/h8dbbnC/ss.png))](https://youtu.be/wIXsSdyPN0Y)



## Contributing
Contributions are welcome. Please submit a Pull Request or open an issue for any enhancements, bug fixes, or feature requests.
